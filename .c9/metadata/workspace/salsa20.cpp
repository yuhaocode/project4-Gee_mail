{"changed":false,"filter":false,"title":"salsa20.cpp","tooltip":"/salsa20.cpp","value":"#include <iostream>\n\n#include \"salsa20.h\"\nusing namespace std;\nusing namespace CryptoPP;\n\n\nusing CryptoPP::Salsa20;\n\n\nusing CryptoPP::AutoSeededRandomPool;\n\n\nusing std::cout;\nusing std::endl;\n\nstring encrypt(string text, string passPhrase){\n\n    string cipherText;\n    int stretch=100;\n    string salt=\"mysalt\";\n    string theHash=\"0\"+passPhrase+salt;\n    theHash=sha256(theHash);\n    int i=0;\n    for(;i<stretch-1;i++){\n        theHash=sha256(theHash+passPhrase+salt);\n    }\n    int l=text.size();\n    byte textBytes[l];\n    byte keyBytes[32];\n    for(i=0;i<32;i++){\n        keyBytes[i]=(byte)theHash[i];\n    }\n    i=0;\n    for(;i<l;i++){\n        textBytes[i]=(byte)text[i];\n    }\n    cipherText=salsa_encrypt(keyBytes,textBytes ,l);\n    return cipherText;\n}\nvoid Print(byte* t,string name,int l){\n  \tcout<<name;\n  \tint i=0;\n    for(;i<l;i++){\n       cout<<t[i];\n    }\n    cout<<endl;\n}\nvoid PrintIv(string t,string name,int l){\n  \tcout<<name;\n  \tint i=0;\n    for(;i<l;i++){\n       cout<<t[i];\n    }\n    cout<<endl;\n}\nvoid convert(string source, byte* target){\n    int i=0;\n    for(;i<source.size();i++){\n      target[i]=source[i];\n    }\n}\n\n//-------------------------------------------------------\nstring salsa_encrypt(byte* keyBytes,byte* textBytes,int numBytes) {\n\tAutoSeededRandomPool prng;\n  \n\tstring ciphertextStr(\"\");\n\t//string plaintextStr(text);\n\t//byte *plaintextBytes = (byte *) plaintextStr.c_str();\n\t//I could statically allocate this, but then changes will require work, and typing\n\tbyte *ciphertextBytes = new byte[numBytes];\n\n\t//~Key and IV Generation/Initialization======================================\n\t/////////////////////////////////////////////////////////////////////////////\n\t/////////////////////////////////////////////////////////////////////////////\n\tbyte iv[8];\n\t//prng.GenerateBlock(key, numBytes);\n\t\n\tprng.GenerateBlock(iv, sizeof(iv));\n\t//~Encryption================================================================\n\t/////////////////////////////////////////////////////////////////////////////\n\t/////////////////////////////////////////////////////////////////////////////\n\n\tSalsa20::Encryption salsa;\n\tsalsa.SetKeyWithIV(keyBytes, 32, iv);\n\tsalsa.ProcessData(ciphertextBytes, textBytes, numBytes);\n\tciphertextStr.assign((char *) ciphertextBytes);\n  std::string s(reinterpret_cast<char*>(iv), sizeof(iv));\n\t//Output plaintext/ciphertext for sanity check\n\tciphertextStr=s+ciphertextStr;\n\t//cout<<\"ciphertextStr : \"<<ciphertextStr<<endl;\n\t//Output newly decrypted plaintext\n\t//cout << \"Plaintext Again: \" << plaintextStr << endl << endl;\n\t//cout << endl << \"SALSA!\" << endl << endl << \"     \" << \"...20...\" << endl;\n    s.clear();\n    delete ciphertextBytes;\n    return ciphertextStr;\n}\n\nstring decrypt(string ciphertextStr,string passPhrase){\n    int stretch=100;\n    string salt=\"mysalt\";\n    string theHash=\"0\"+passPhrase+salt;\n    theHash=sha256(theHash);\n    int i=0;\n    for(;i<stretch-1;i++){\n        theHash=sha256(theHash+passPhrase+salt);\n    }\n    byte ivBytes[8];\n    byte keyBytes[32];\n    for(i=0;i<32;i++){\n        keyBytes[i]=(byte)theHash[i];\n    }\n    i=0;\n    for(;i<8;i++){\n        ivBytes[i]=(byte)ciphertextStr[i];\n    }\n    byte ciphertextBytes[ciphertextStr.size()-8];\n   // \n    string Text=salsa_decrypt(ciphertextStr.substr(8),keyBytes,ivBytes);\n    return Text;\n}\n\nstring salsa_decrypt(string ciphertextStr, byte* key, byte* iv) {\n  string plaintextStr;\n  byte* plaintextBytes = new byte[ciphertextStr.size()];\n  byte *ciphertextBytes = new byte[ciphertextStr.size()];\n  convert(ciphertextStr,ciphertextBytes);\n  plaintextStr.assign(\"\");\n  \n  \n  Salsa20::Encryption salsa;\t\n\t//Reset Key & IV\n\t//!!! THIS IS IMPORTANT: If you do not reset the stream cipher the data will\n\t\t//be encrypted again with a different part of the streaming key\n\t\t//Resetting the key & IV ensure that the same key is used, and we decrypt\n\t/////////////////////////////////////////////////////////////////////////////\n\t/////////////////////////////////////////////////////////////////////////////\n\tsalsa.SetKeyWithIV(key, 32, iv);\n  salsa.ProcessData(plaintextBytes, ciphertextBytes, ciphertextStr.length());\n\tplaintextStr.assign((char *) plaintextBytes);\n\n\t//Output newly decrypted plaintext\n\n\n  delete plaintextBytes;\n  delete ciphertextBytes;\n\treturn plaintextStr;\n}\n\n\n// int main(){\n// string f = encrypt(\"abcfewfeefwe ewfwef\",\"124\");\n//   cout<<f<<endl;\n//   string h =decrypt(f,\"124\");\n//   cout<<h<<endl;\n//   return 0;\n// }\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":2322,"scrollleft":0,"selection":{"start":{"row":158,"column":4},"end":{"row":158,"column":4},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1479419094480}